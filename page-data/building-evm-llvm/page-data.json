{"componentChunkName":"component---node-modules-etclabscore-gatsby-theme-pristine-src-templates-default-tsx","path":"/building-evm-llvm","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Building EVM LLVM\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Building EVM LLVM\"), mdx(\"p\", null, \"The project compiles like other LLVM projects. The target's name is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EVM\"), \", but since it is not yet finalized, you have to specify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=EVM\"), \" when you compile it.\"), mdx(\"p\", null, \"In short,  you can use the following to build the backend:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"git clone git@github.com:etclabscore/evm_llvm.git\\ncd evm_llvm\\ngit checkout EVM\\nmkdir build && cd build\\ncmake -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=EVM ..\\nmake -j8\\n\")), mdx(\"p\", null, \"Let's try to use a simple C file to test our compiler:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"unsigned x;\\nint abc(unsigned a, unsigned b, unsigned c) {\\n  if (c > 0) {\\n    return a + x;\\n  } else {\\n    return a + b;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Prerequisite: You have to install \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clang\"), \" and use it to generate LLVM IR first:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"clang -S -emit-llvm test.c\\n\")), mdx(\"p\", null, \"This will generate a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test.ll\"), \" file which should be the LLVM IR equivalent of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test.c\"), \" file. Then we can generate EVM binary or assembly from it. In order to use the backend to generate EVM assembly, you have to specify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-mtriple=evm\"), \" when calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"llc\"), \". An example is as follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"./build/bin/llc -mtriple=evm test.ll -o test.s\\n\")), mdx(\"p\", null, \"The generated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test.s\"), \" file contains the compiled EVM assembly code. Note that the generated code is the function body itself. In order to generate a complete smart contract source code we need to use a smart contract creator function, which we will talk about it in another page.\"), mdx(\"p\", null, \"Notice that you can also get the binary code of the function body by emitting an object file:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"./build/bin/llc -mtriple=evm -filetype=obj test.ll -o test.o\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Building EVM LLVM The project compiles like other LLVM projects. The target's name is  EVM , but since it is not yet finalized, you have toâ€¦","fields":{"slug":"/building-evm-llvm"},"frontmatter":{"title":"Building EVM LLVM"}}},"pageContext":{"slug":"/building-evm-llvm","prev":{"name":"Introduction","link":"/introduction","ignoreNextPrev":null},"next":{"name":"Compiling Smart Contracts","link":"/compiling-smart-contracts","ignoreNextPrev":null}}}}