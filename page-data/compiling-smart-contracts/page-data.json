{"componentChunkName":"component---node-modules-etclabscore-gatsby-theme-pristine-src-templates-default-tsx","path":"/compiling-smart-contracts","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Compiling Smart Contracts\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Compiling Smart Contracts\"), mdx(\"h3\", null, \"The Contract constructor function\"), mdx(\"p\", null, \"Because EVM's execution always start from the beginning of the code (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pc = 0\"), \"), there must be a way to handle more complicated contract behaviours. In EVM LLVM, we use a function to describe the function handling. It is called contract constructor function. To implement the function, developers are expected to respect the following contract constructor properties:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The constructor should be the first function in the generated LLVM IR.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The constructor should be named \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"solidity.main\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"main\"), \" (could change in the future). The backend recognizes these specific names and will generate different call codes.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The constructor should not take any arguments.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The constructor should initialize the function's \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"free memory pointer\"), \", which is located at address \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x40\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"free memory pointer\"), \" is like the usual frame pointer, used to calculate function frames and stack allocations. Because it is located at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x40\"), \", so you cannot initialize it to a smaller number.\")), mdx(\"h3\", null, \"Skeleton example of a very small constructor function\"), mdx(\"p\", null, \"Here is an illustration of the skeleton of a small smart contract:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"declare i256 @llvm.evm.calldataload(i256)\\ndeclare void @llvm.evm.return(i256, i256)\\ndeclare void @llvm.evm.mstore(i256, i256)\\n\\ndefine void @main() {\\nentry:\\n  call void @llvm.evm.mstore(i256 64, i256 128)\\n  %0 = call i256 @llvm.evm.calldataload(i256 0)\\n  %1 = call i256 @llvm.evm.calldataload(i256 32)\\n  %2 = call i256 @add(i256 %0, i256 %1)\\n  call void @llvm.evm.mstore(i256 0, i256 %2)\\n  call void @llvm.evm.return(i256 0, i256 32)\\n  unreachable\\n}\\n\\ndefine i256 @add(i256, i256) #0 {\\n  %3 = alloca i256, align 4\\n  %4 = alloca i256, align 4\\n  store i256 %0, i256* %3, align 4\\n  store i256 %1, i256* %4, align 4\\n  %5 = load i256, i256* %3, align 4\\n  %6 = load i256, i256* %4, align 4\\n  %7 = add nsw i256 %5, %6\\n  ret i256 %7\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Usually, it is the frontend's responsibility to do the smart contract's plumbing, including the contract's constructor function. \"), \" We need the language frontends to generate corresponding LLVM IR code.\"), mdx(\"p\", null, \"This smart contract does the following things;\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Initialize the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"free memory pointer\"), \" to 128\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"parse the first two 32-byte inputs\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"call the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@add\"), \" function and supply it with the two parsed arguments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In the function \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@add\"), \", we simply add the two arguments, and return it\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@main\"), \" function, return the retrieved value using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"llvm.evm.return\"), \" intrinsic.\")), mdx(\"h3\", null, \"Compiling the smart contract\"), mdx(\"p\", null, \"Let's put the above smart contract code into a file named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test.ll\"), \", and we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"llc\"), \" to generate EVM binary:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"llc -mtriple=evm -filetype=obj test.ll -o test.o\\n\")), mdx(\"h3\", null, \"Running the contract\"), mdx(\"p\", null, \"A generated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".o\"), \" file is in binary format. To see its content in hex, try to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"xxd\"), \", for example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"xxd -p -cols 65536 test.o\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"xxd\"), \" will emit a hex string representation of the binary format. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"xxd\"), \" will try to break the line if it is too long. Here we specify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-cols 65536\"), \" to avoid linebreaking. After calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"xxd\"), \", you should see some output such as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"5b600135600080803561003d909192939091604051806108200152604051610840016040526004580192565b60405160209003516040529052602090f35b80826040519190915260206040510152019056\\n\")), mdx(\"p\", null, \"That is what we need to execute using an EVM engine. Let's try to do it using Geth's EVM. Remember that we need to supply two input arguments, so the command line should be like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"evm --input 1234567890123456789012345678901234567890123456789012345678901234 --code 5b600135600080803561003d909192939091604051806108200152604051610840016040526004580192565b60405160209003516040529052602090f35b80826040519190915260206040510152019056 run\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"evm\"), \" will emit the result of the two added files:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"0x468acf08a2468acf08a2468acf08a2468acf08a2468acf08a2468acf08a24634\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Compiling Smart Contracts The Contract constructor function Because EVM's execution always start from the beginning of the code ( pc =â€¦","fields":{"slug":"/compiling-smart-contracts"},"frontmatter":{"title":"Compiling Smart Contracts"}}},"pageContext":{"slug":"/compiling-smart-contracts","prev":{"name":"Build EVM-LLVM","link":"/building-evm-llvm","ignoreNextPrev":null},"next":{"name":"Emitting Program Metadata","link":"/emitting-program-metadata","ignoreNextPrev":null}}}}