{"componentChunkName":"component---node-modules-etclabscore-gatsby-theme-pristine-src-templates-default-tsx","path":"/future-works","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Future Works\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Future Works\"), mdx(\"h1\", null, \"Functionalities\"), mdx(\"h2\", null, \"Experimental support of landing pad\"), mdx(\"p\", null, \"Landingpad is used to support exception handling.\"), mdx(\"h2\", null, \"Experimental support of Heap allocation\"), mdx(\"p\", null, \"EVM does not have a heap space, so we cannot use heap allocations. We might be able to do around it.\"), mdx(\"h2\", null, \"Constant symbol table support\"), mdx(\"h2\", null, \"Metadata export\"), mdx(\"h1\", null, \"Optimizations\"), mdx(\"h2\", null, \"Support more than 16 local variables\"), mdx(\"p\", null, \"EVM can only support retrieval of an element up to depth of 16 from the stack top using instructions \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SWAP1\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SWAP16\"), \" -- resulting a limitation in Solidity compiler that can only support 16 local variables. At this moment, EVM LLVM will also face a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stack too deep\"), \" issue if the variables in a single basic block is more than 16.\"), mdx(\"p\", null, \"But in LLVM we can totally work around this issue, and do a much better job. With dataflow analysis and register allocation algorithm, we can have near-optimal variable assignment (on the stack or on memory stack) in linear time.\"), mdx(\"h2\", null, \"Instruction scheduling\"), mdx(\"p\", null, \"Arranging the order of the opcodes in EVM binary is critical to its performance. Instructions has to be arranged so that we have minimal stack manipulation over head (the opcodes that does not do actual computation, but rather, reorder stack operands' relative position to the top of stack). \"), mdx(\"p\", null, \"EVM LLVM backend is designed in such a way that a scheduler before register allocation can be implemented to reduce the stack operation overhead. \"), mdx(\"h2\", null, \"Improve EVM calling conventions\"), mdx(\"p\", null, \"When calling a subroutine, The return address is the first argument and resides at top of stack. This is non-optimal because the return address will definitely not be used until the very end of the subroutine, and taking up a visible slot is expensive. We can re-arrange the return address to be at the end of argument so it will not have to be reached until we want to return from subroutine.\"), mdx(\"h2\", null, \"Re-materialization of constants\"), mdx(\"p\", null, \"usual small constants should not stay in stack --- they should be rematerialized whenever it is needed.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Future Works Functionalities Experimental support of landing pad Landingpad is used to support exception handling. Experimental support ofâ€¦","fields":{"slug":"/future-works"},"frontmatter":{"title":"Future Works"}}},"pageContext":{"slug":"/future-works","prev":{"name":"Function Layouts","link":"/function-layouts","ignoreNextPrev":null},"next":{"name":"Handling EVM specific operations","link":"/handling-evm-specific-ops","ignoreNextPrev":null}}}}