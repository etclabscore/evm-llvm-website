{"componentChunkName":"component---node-modules-etclabscore-gatsby-theme-pristine-src-templates-default-tsx","path":"/the-evm-calling-conventions","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The EVM Calling Conventions\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"The EVM Calling Conventions\"), mdx(\"p\", null, \"The EVM architecture is a simplistic structure, but it has everything we need to do usual program computations. \"), mdx(\"h2\", null, \"Types of calls\"), mdx(\"p\", null, \"There are two types of calls in an EVM smart contract:\\n1. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Internal calls\"), \". Internal calls are referred to function calls within a smart contract. An example is that we have two defined function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \", and somewhere in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" we save our context and change our execution flow to the beginning of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \".\\n2. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"External calls\"), \". Or cross-contract calls. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" are defined in different deployed EVM contract and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" in its context.\"), mdx(\"h2\", null, \"Internal call conventions\"), mdx(\"p\", null, \"Up to ETH 1.5, there is no link and jump EVM opcode for easy handling of subroutines(even though some \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ethereum/EIPs/issues/2315\"\n  }), \"discussions\"), \" are on-going). So we have to manually handle subroutine calls. Here are the calling conventions for an internal calls:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"current subroutine's frame pointer is saved at stack, at memory location \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$fp - 32\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$fp\"), \" is the subroutine call's frame pointer.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"arguments are all pushed on stack, along with the return address. Argument with smaller index number occupies a stack slot on top of another argument with a larger index number. For example, when we want to do a function call: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"func abc(x, y, z)\"), \", here is the arrangement of the arguments:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"               +-----------+\\n               |Return Addr|\\n               +-----------+\\n               |     X     |\\n               +-----------+\\n               |     Y     |\\n               +-----------+\\n Current FP    |     Z     |\\n+------------> +-----------+\\n               |  Old FP   |\\n               +-----------+\\n               |   .....   |\\n               +-----------+\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note: Putting the return address on top of the stack is because it is easier to compute the location, but this will result in more stack manipulation overhead for the subroutine calls. We will improve this design in a later version.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A subroutine's return value is stored on stack top.\\n\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Note: currently we only support one return value. In the future we will improve it by supporting multiple return values.\"))), mdx(\"h2\", null, \"Procedure of a subroutine call\"), mdx(\"p\", null, \"To illustrate the procedure for a subroutine call, we need to do the following to save the context of current function execution:\\n1. calculate the current frame size. The frame size should be the size sum of: a) slots occupied by frame objects, b) slots occupied by spilled variables, and c) one more slot for storing current frame pointer. let's assume the frame size is calculated to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"%frame_size\"), \".\\n2. save existing frame pointer. The frame pointer resides at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x40\"), \".\\n3. bump the frame pointer to: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$fp = $fp + %frame_size\"), \". After that, we can easily restore the old frame pointer by looking at location \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$fp - 32\"), \".\\n4. push all subroutine arguments in order on to stack.\\n5. push return address onto stack.\\n6. push the beginning address of subroutine and jump.\"), mdx(\"p\", null, \"Right before we return from a subroutine, the stack should be empty and the return address should be at the top of the stack. When returning from a subroutine call, we should do the following:\\n1. push return value on to top of stack.\\n2. Do a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swap1\"), \" to move the return address to top of stack\\n3. jump to return address and resume the execution in caller function.\\nIf the function returns nothing, simply jump to return address.\"), mdx(\"p\", null, \"After jumping back to caller, we have to resume the execution:\\n1. restore caller's frame pointer by storing the value at location \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$fp - 32\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x40\"), \".\"), mdx(\"h2\", null, \"External calls\"), mdx(\"p\", null, \"External calls are implemented using intrinsic calls.\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TODO\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"The EVM Calling Conventions The EVM architecture is a simplistic structure, but it has everything we need to do usual program computationsâ€¦","fields":{"slug":"/the-evm-calling-conventions"},"frontmatter":{"title":"The EVM Calling Conventions"}}},"pageContext":{"slug":"/the-evm-calling-conventions","prev":{"name":"Stack & Memory management","link":"/stack-and-memory-management","ignoreNextPrev":null},"next":{"name":"Types and type conversions","link":"/types-and-type-conversions","ignoreNextPrev":null}}}}