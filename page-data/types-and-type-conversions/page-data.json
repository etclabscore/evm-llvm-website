{"componentChunkName":"component---node-modules-etclabscore-gatsby-theme-pristine-src-templates-default-tsx","path":"/types-and-type-conversions","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Types and Type Conversions\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Types and Type Conversions\"), mdx(\"h2\", null, \"Newly supported Types\"), mdx(\"p\", null, \"So far the open-source LLVM trunk has not yet implemented bit size support larger than 128bits. We have implemented 256bit supports in our own backend, and is considering contributing them back to main trunk.\"), mdx(\"p\", null, \"Users are allowed to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i256\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i160\"), \" data types in their generated LLVM IR, which represent 256bit integer types and 160bit integer types respectively.\"), mdx(\"p\", null, \"Even though all EVM data types are 256bit in length internally. We are still able to offer support to smaller data types. However, users are encouraged to use 256bit data types internally because it is free.\"), mdx(\"h2\", null, \"Contract Input Argument Types -- The Solidity convention\"), mdx(\"p\", null, \"Contract arguments are passed to EVM via the call data field. The function dispatcher is responsible to extract input arguments from call data. \"), mdx(\"p\", null, \"In Solidity's convention, the arguments in call data are padded to 32 bytes long if its data type's length is shorter. So, in order to maintain the convention, the function dispatcher needs to truncate the input arguments to the defined size in the function that is going to be called.\"), mdx(\"p\", null, \"This is undoubtedly inefficient, so users are discouraged to use smaller data types. \"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Types and Type Conversions Newly supported Types So far the open-source LLVM trunk has not yet implemented bit size support larger thanâ€¦","fields":{"slug":"/types-and-type-conversions"},"frontmatter":{"title":"Types and Type Conversions"}}},"pageContext":{"slug":"/types-and-type-conversions","prev":{"name":"The EVM Calling Conventions","link":"/the-evm-calling-conventions","ignoreNextPrev":null},"next":null}}}