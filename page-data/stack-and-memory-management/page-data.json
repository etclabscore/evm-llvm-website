{"componentChunkName":"component---node-modules-etclabscore-gatsby-theme-pristine-src-templates-default-tsx","path":"/stack-and-memory-management","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Stack and Memory management\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Stack and Memory management\"), mdx(\"h2\", null, \"Variables\"), mdx(\"p\", null, \"In the context of stack machine, a variable refers to an operand that will be consumed by an opcode. In EVM LLVM, variables are treated as virtual registers, until they are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"stackfied\"), \" (convert register-based code to stack-based code) right before lowering to machine code. \"), mdx(\"p\", null, \"In LLVM's internal SSA representation mode, it is fairly easy to compute a register's live range (the range from its assignment to its last use). Variables are treated differently with regard to its live range. Local variables (variables that its liveness only extends within a single basic block) will live entirely on the stack, while non-local variables (variables that live across basic blocks) will be spilled to a memory slot allocated by the compiler.\"), mdx(\"h3\", null, \"Frame Pointer (or Free Memory Pointer)\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Call_stack#Stack_and_frame_pointers\"\n  }), \"Stack pointers and frame pointers\"), \" are essential to support subroutine calls. Frame pointer is used to record the structure of stack frames. Because we do not have registers in EVM, we will have to store stack frame pointer in memory locations. Usually, we put stack frame pointer at location \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x40\"), \", and we follow Solidity compiler's convention to initialize it to value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"128\"), \". So the stack frame of the first function starts at that location. The value of frame pointer changes as the contract calls a subroutine or exits from a subroutine. Whenever we need to have access to frame pointer, we will retrieve its value from that specific location.\"), mdx(\"h3\", null, \"Memory stack\"), mdx(\"p\", null, \"Part of the memory is used as a stack for function calls and variable spills. The structure is described as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The stack goes from lower address to higher address, as different from usual hardware implementations.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The frame is arranged into 3 parts:\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"frame object locations\"), \". Each frame object has its own frame slot. Frame object \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" will have a 32 byte space starting from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$fp + (x * 32)\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$fp\"), \" is the frame pointer, and is stored at location \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x40\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"spilled variables\"), \". Variable that are unable to be fully stackified will reside on the memory stack. In codegen, each spilled variable will have an index, and each index refers to a memory slot. A spilled variable that bears index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \", will reside at location \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$fp + (number_of_frame_objects * 32) + (y * 32)\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"subroutine context\"), \". Like a regular register machine, the memory stack is used to store subroutine context so as to support function calls. Two slots are allocated at the end of current frame for a) the existing frame pointer, and b) return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PC\"), \" address. \")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Here is an example showing a stack frame right before we jump into a subroutine:\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"  Stack top                                    Higher address\\n +-----------> +----------------------------+ <--------------+\\n               |                            |\\n               |     Return Address         |\\n               |                            |\\n               +----------------------------+\\n               |                            |\\n               |     Function argument      |\\n   new FP      |                            |\\n +-----------> +----------------------------+\\n               |                            |\\n               |    Saved frame pointer     |\\n               |     (Start of frame)       |\\n               +----------------------------+\\n               |                            |\\n               |     Stack Object 1         |\\n               |                            |\\n               +----------------------------+\\n               |                            |\\n               |     Frame Object 2         |\\n               |                            |\\n               +----------------------------+\\n               |                            |\\n               |     Frame Object 1         |\\nStart of frame |                            |   Lower address\\n+------------> +----------------------------+ <----------------+\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Stack and Memory management Variables In the context of stack machine, a variable refers to an operand that will be consumed by an opcodeâ€¦","fields":{"slug":"/stack-and-memory-management"},"frontmatter":{"title":"Stack and Memory management"}}},"pageContext":{"slug":"/stack-and-memory-management","prev":{"name":"Running integrated tests in EVM evniorment","link":"/run-integrate-tests-in-evm-env","ignoreNextPrev":null},"next":{"name":"The EVM Calling Conventions","link":"/the-evm-calling-conventions","ignoreNextPrev":null}}}}